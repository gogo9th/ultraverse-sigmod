#ifndef STATE_LOG_HDR_INCLUDED
#define STATE_LOG_HDR_INCLUDED

#include <string.h>
#include <vector>
#include <string>

#define STATE_BACKUP_DATABASE "STATE_LOG_BACKUP_DB"
#define STATE_CHANGE_DATABASE "STATE_LOG_CHANGE_DB"
#define STATE_TRIGGER_DATABASE "STATE_TRIGGER_DB"
#define STATE_GROUP_DATABASE "STATE_GROUP_DB"

#define STATE_GROUP_TABLE "STATE_GROUP_TABLE"

#define STATE_ALTER_COMMENT_STRING "FOR STATE METADATA LOCK"
#define STATE_QUERY_COMMENT_STRING "/* GENERATED BY STATE QUERY */"
#define STATE_GROUP_COMMENT_STRING "/* GENERATED BY STATE GROUP */"

#define STATE_HASH_EVENT_KEY 30015
#define STATE_HASH_EVENT_MSG_TYPE 1
#define STATE_HASH_EVENT_MAX_SIZE 4
struct state_hash_event
{
  long msgtyp;
  char table[STATE_HASH_EVENT_MAX_SIZE];
};

//상태 변환에서 사용하는 에러 번호 목록
//ER_ERROR_LAST 보다 커야 함
#define ER_STATE_START 5000
#define ER_STATE_TEMP_TABLE (ER_STATE_START + 1)
#define ER_STATE_VIEW_TABLE (ER_STATE_START + 2)
#define ER_STATE_VIEW_RENAME (ER_STATE_START + 3)
#define ER_STATE_TABLE_RENAME (ER_STATE_START + 4)
#define ER_STATE_TRUNC_VIEW (ER_STATE_START + 5)
#define ER_STATE_CREATE_ACL (ER_STATE_START + 6)
#define ER_STATE_CREATE_DB (ER_STATE_START + 7)
#define ER_STATE_OPEN_TABLE (ER_STATE_START + 8)
#define ER_STATE_ALTER_TABLE (ER_STATE_START + 9)
#define ER_STATE_CLONE_OPEN (ER_STATE_START + 10)
#define ER_STATE_CLONE_PREPARE (ER_STATE_START + 11)
#define ER_STATE_CLONE_FIX (ER_STATE_START + 12)
#define ER_STATE_CLONE_CREATE (ER_STATE_START + 13)
#define ER_STATE_CLONE_EXISTS (ER_STATE_START + 14)

struct state_log_time
{
  long sec;
  ulong sec_part;

  state_log_time() : sec(0), sec_part(0) {}
  state_log_time(long sec, ulong sec_part) : sec(sec), sec_part(sec_part) {}

  state_log_time &operator++()
  {
    if (sec_part == 999999)
    {
      ++sec;
      sec_part = 0;
    }
    else
    {
      ++sec_part;
    }
    return *this;
  }

  state_log_time &operator--()
  {
    if (sec_part == 0)
    {
      --sec;
      sec_part = 999999;
    }
    else
    {
      --sec_part;
    }
    return *this;
  }

  bool operator==(const struct state_log_time &rhs) const
  {
    return (sec == rhs.sec && sec_part == rhs.sec_part);
  }
  bool operator<(const struct state_log_time &rhs) const
  {
    if (sec < rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part < rhs.sec_part)
      return true;
    else
      return false;
  }
  bool operator<=(const struct state_log_time &rhs) const
  {
    if (sec < rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part <= rhs.sec_part)
      return true;
    else
      return false;
  }
  bool operator>(const struct state_log_time &rhs) const
  {
    if (sec > rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part > rhs.sec_part)
      return true;
    else
      return false;
  }
  bool operator>=(const struct state_log_time &rhs) const
  {
    if (sec > rhs.sec)
      return true;
    else if (sec == rhs.sec && sec_part >= rhs.sec_part)
      return true;
    else
      return false;
  }
};

enum en_state_log_foreign_key_type : uint8_t
{
  en_foreign_key_none = 0,
  en_foreign_key_add,
  en_foreign_key_drop,
};

enum en_state_log_table_access_type : uint8_t
{
  en_table_access_read = 0,
  en_table_access_write,
};

enum en_state_log_foreign_key_opt_type : uint8_t
{
  en_foreign_key_opt_none = 0,
  en_foreign_key_opt_check,
};

struct state_log_hdr_foreign
{
  state_log_hdr_foreign() : table_type(en_foreign_key_none),
                            update_type(en_foreign_key_opt_none),
                            delete_type(en_foreign_key_opt_none),
                            access_type(en_table_access_read),
                            foreign_name_length(0),
                            foreign_table_length(0),
                            columns_length(0),
                            foreign_columns_length(0)
  {
  }

  state_log_hdr_foreign(
      en_state_log_foreign_key_type _table_type,
      en_state_log_foreign_key_opt_type _update_type,
      en_state_log_foreign_key_opt_type _delete_type,
      en_state_log_table_access_type _access_type)
      : table_type(_table_type),
        update_type(_update_type),
        delete_type(_delete_type),
        access_type(_access_type),
        foreign_name_length(0),
        foreign_table_length(0),
        columns_length(0),
        foreign_columns_length(0)
  {
  }
  en_state_log_foreign_key_type table_type;
  en_state_log_foreign_key_opt_type update_type;
  en_state_log_foreign_key_opt_type delete_type;
  en_state_log_table_access_type access_type;
  uint16_t foreign_name_length;
  uint16_t foreign_table_length;
  uint16_t columns_length;
  uint16_t foreign_columns_length;
};

struct state_log_hdr
{
  state_log_time start_time;
  uint64_t xid;

  uint8_t is_user_query;
  uint8_t foreign_count;
  uint8_t data_column_count;
  uint8_t where_column_count;
  uint16_t sql_command;
  uint16_t query_length;

  uint16_t read_table_length;
  uint16_t write_table_length;

  uint32_t foreign_length;
  uint32_t data_column_item_length;
  uint32_t where_column_item_length;
};

enum en_state_log_column_item_type : uint16_t
{
  en_column_item_none  = (uint16_t)-1, 
  en_column_item_field = 0,  // Item::FIELD_ITEM
  en_column_item_func  = 1,  // Item::FUNC_ITEM
  en_column_item_cond  = 13, // Item::COND_ITEM

  //내부적으로만 사용
  en_column_item_int   = 5,  // Item::INT_ITEM
  en_column_item_date  = 29, // Item::DATE_ITEM
  en_column_item_real  = 6,  // Item::REAL_ITEM
  en_column_item_deci  = 24, // Item::DECIMAL_ITEM
  en_column_item_str   = 4,  // Item::STRING_ITEM
  en_column_item_nul   = 7,  // Item::NULL_ITEM

};

// item_type 이 field 일때 sub_type 은 해당 내용 사용
enum en_state_log_column_data_type : uint16_t
{
  en_column_data_null = 0,
  en_column_data_int,
  en_column_data_uint,
  en_column_data_double,
  en_column_data_string,
  en_column_data_from_subselect = 0x80,
};
inline en_state_log_column_data_type &operator|=(en_state_log_column_data_type &lhs, en_state_log_column_data_type rhs)
{
  lhs = (en_state_log_column_data_type)(lhs | rhs);
  return lhs;
}

// item_type 이 func 일때 sub_type 은 해당 내용 사용
enum en_state_log_column_func_type : uint16_t
{
  en_column_func_eq = 1,       // Item_func::EQ_FUNC
  en_column_func_equal = 2,    // Item_func::EQUAL_FUNC
  en_column_func_ne = 3,       // Item_func::NE_FUNC
  en_column_func_lt = 4,       // Item_func::LT_FUNC
  en_column_func_le = 5,       // Item_func::LE_FUNC
  en_column_func_gt = 7,       // Item_func::GT_FUNC
  en_column_func_ge = 6,       // Item_func::GE_FUNC
  en_column_func_between = 15, // Item_func::BETWEEN
};

// item_type 이 cond 일때 sub_type 은 해당 내용 사용
enum en_state_log_column_cond_type : uint16_t
{
  en_column_cond_and = 12, // Item_func::COND_AND_FUNC
  en_column_cond_or = 13,  // Item_func::COND_OR_FUNC
};

struct state_log_column_item
{
  state_log_column_item() : item_type(en_column_item_none),
                            arg_count(0),
                            data_length(0),
                            data(NULL)
  {
  }

  en_state_log_column_item_type item_type;
  union _sub_type {
    _sub_type()
    {
      memset(this, 0, sizeof(sub_type));
    }
    en_state_log_column_data_type data;
    en_state_log_column_func_type func;
    en_state_log_column_cond_type cond;
  } sub_type;
  // uint16_t func_type; //en_state_log_column_data_type
  uint16_t arg_count;
  uint16_t data_length;
  unsigned char *data;
  std::vector<unsigned char> data_array;
};
static const int state_log_column_item_length = sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint16_t) + sizeof(uint16_t);

enum en_state_hash_table_from : uint32_t
{
  en_from_backup_table = 1,
  en_from_origin_table
};
struct st_state_hash_create_table
{
  en_state_hash_table_from from;
  uint32_t from_sec;
  uint32_t from_sec_part;
  size_t length;
  //char name[n]
};

struct st_state_hash_write_table
{
  size_t length;
  //char name[n]
};

struct st_state_hash_check
{
  uint32_t target_query_sec;
  uint32_t target_query_sec_part;

  size_t create_table_count;
  //struct st_state_hash_create_table[n]

  size_t write_table_count;
  //struct st_state_hash_write_table[n]
};

struct st_state_group
{
  uint64_t group_id;
  uint64_t trx_id;
  uint32_t time_sec;
  uint32_t time_usec;
};

#endif /* STATE_LOG_HDR_INCLUDED */
